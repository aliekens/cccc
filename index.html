<html>
  <script src="js/ajax.js"></script>
  <script src="js/svg.js"></script>
<body>
  <h1>CCCC - Chaos Communication Camp Counter</h1>
  
  <p><b>Done before we even started ;-)</b> - It seems the svg data is not
  allowed to be retrieved outside the original domain, so no live updates are
  possible, and I'm not going to fetch and update the repository with a fresh
  cache every hour/day/... Too bad ;-/</p>
  
  <p><b>BUT...</b> If you're using Safari (FireFox also blocks it, haven't
  tested Chrome, but that comes with a command-line switch to disable it it
  seems, YMMV), you can clone the repo and look at the page locally, because
  from a local file the same-origin check isn't validated it
  appears.<br>Minimal survival commands:
<pre>
  $ git clone https://github.com/christophevg/cccc.git
  $ cd cccc
  $ git checkout gh-pages
  $ open index.html
</pre>
</p>

  <hr>

  <p>This is just a little bit of fun, trying to compute the number of hackers
  that will roam <a href="https://events.ccc.de/camp/2015">CCC15</a>. Based on
  the information found in the <a
  href="https://tickets.events.ccc.de/graph/">target graphs</a>, I want to try
  to estimate the number of tickets sold, just to enjoy the vast growing amount
  of hackers I will share the camp grounds with.</p>
  
  <p>On the other hand, its also a case pro Open Data. It's an example of the
  not so cool way of doing things these days. In stead of publishing a json
  file with the data (# of tickets per category, # of t-shirts per category)
  and computing a rendering on the client-side, the data is mangled into one
  representation on the server-side, requiring other consumers to reengineer
  the representation to an approximation of the original data.</p>
  
  <p>I thought hackers would be on the forefront of the openness of where the
  web is heading. Seems I'm wrong :-(</p>
  
  <p>Finally, it's also an excuse to have a little fun with JavaScript again,
  after a long time, exercising a bit for things to come :-)</p>

  <h2>Data</h2>

  <p>The following tables contain the latest data, extracted from the published
  SVG graphs.</p>
  
  <h3>Revenue</h3>
  <table border="1">
    <thead><tr><th>subject</th><th>&euro;</th></tr></thead>
    <tbody id="table"></tbody>
  </table>
  
  <h3>Average Ticket Price...</h3>

  <p>... is currently computed to &euro;<span id="avg-ticket-price"></span></p>
  
  <h2>Estimation Time</h2>
  
  <p>Let's go from very basic to more specific...</p>
  
  <h3>The very rough one</h3>

  <p>Summing the different ticket revenues, dividing it by the average price,
  gives us a rough estimate of the number of tickets sold. The total in ticket
  revenue is &euro;<span id="total-ticket-revenue"></span>. This brings the
  rough estimate to <b><span id="rough-estimate"></span> campers</b>. </p>
  
  <h3>Taking into Account the Categories</h3>
  
  <p>But different ticket prices are in effect. The goal is to allow those who
  can to <i>chip</i> a bit for those who can't. I think that's commendable. But
  it also means that some payments count for less tickets. Let's start with
  taking into account the categories and come up with an interval.</p>
  
  <p>The following table (as also shown in <a
  href="https://events.ccc.de/camp/2015/wiki/Static:Tickets">https://events.ccc.
   de/camp/2015/wiki/Static:Tickets</a>) gives an overview of the tickets
  categories and their pricing:</p>
  
  <table border="1">
    <thead><tr><th>category</th><th>price</th><th>lower</th><th>upper</th></tr></thead>
    <tbody>
      <tr>
        <th>Low budget</th><td>&euro;180, &euro;200</td>
        <td id="low-budget-lower"></td><td id="low-budget-upper"></td>
      </tr>
      <tr>
        <th>Standard</th><td>&euro;220</td>
        <td colspan="2" id="standard-amount"></td>
      </tr>
      <tr>
        <th>Supporter</th><td>&euro;240, &euro;260, &euro;280, &euro;300</td>
        <td id="supporter-lower"></td><td id="supporter-upper"></td>
      </tr>
      <tr>
        <th>Business</th><td>&euro;450, &euro;60, &euro;750</td>
        <td id="business-lower"></td><td id="business-upper"></td>
      </tr>
      <tr>
        <th>&nbsp;</th><td>&nbsp;</td>
        <td id="interval-minimum-table"></td><td id="interval-maximum-table"></td>
      </tr>
    </tbody>
  </table>
  
  <p>The two additional columns, provide the lower and upper bound of the
  interval of possible ticket sales given the prices. These numbers allow us to
  add the lower and upper bounds to come up with a minimum and maximum number
  of campers.</p>
  
  <p>Taking the categories into account, the amount of campers to expect can
  range <b>between <span id="interval-minimum-text"></span> and <span
  id="interval-maximum-text"></span></b>.</p>
  
  <p><i>more to come...</i></p>
  
</body>

<script>
(function() {
  
  var labels           = {};  // { serie-x : label }
  var revenues         = {};  // { serie-x : [value] } // cummulative values
  var ticket_revenues  = [];  // [value]

  var avg_ticket_price = [];  // [value]

  var tickets          = {};  // { serie-x : { upper: [value], lower: [value] }}
  var tickets_bounds   = { "minimum": [], "maximum": [] };

  function chart_single_processor(svg) {
    var doc = Svg.parse(svg);

    // process this graph's data
    extract_series_labels(doc);
    extract_series_revenues(doc);

    // continue with the average ticket price
    Ajax.using(chart_avg_processor).fetch("chart_avg.svg");
  }
  
  function extract_series_labels(doc) {
    // fill labels[serie-x] = label
    var legends = doc.getElementsByClassName("legend reactive activate-serie");
    for(var i=0; i<legends.length; i++) {
      var serie = legends[i].id.replace("activate-", "");
      var label = legends[i].getElementsByTagName("title");
      if(label.length <= 0) { label = legends[i].getElementsByTagName("text"); }
      labels[serie] = label[0].textContent
                              .toLowerCase()
                              .replace(" ", "-");
    }
  }
  
  function extract_series_revenues(doc) {
    // fill revenues[] = { serie: [revenues] }
    var series = doc.getElementsByClassName("plot overlay")[0]
                    .getElementsByClassName("series");
    for(var i=0; i<series.length; i++) {
      extract_revenues(series[i])
    }
  }
  
  function extract_revenues(series) {
    // -> let's believe the series are named serie-x ;-)
    var id = series.className.baseVal.match(/serie-[0-9]/)[0];
    // dots is the actual series
    var dots  = series.getElementsByClassName("dots");

    revenues[id] = [];
    for(var i=0; i<dots.length;i++) {
      revenues[id].push( parseInt(
        dots[i].getElementsByClassName("value")[0].textContent
      ));
    }
  }
  
  function chart_avg_processor(svg) {
    var doc = Svg.parse(svg);

    var series = doc.getElementsByClassName("plot overlay")[0]
                    .getElementsByClassName("series")[0]
                    .getElementsByClassName("dots");
    for(var i=0; i<series.length;i++) {
      avg_ticket_price.push( parseFloat(
        series[i].getElementsByClassName("value")[0].textContent
      ));
    }
  
    // now compute and render results
    process_data();
  }
  
  function process_data() {
    render_totals_table();
    render_avg_ticket_price();
    compute_and_render_ticket_revenue();
    compute_and_render_rough_estimate();
    compute_and_render_category_intervals();
  }

  function render_totals_table() {
    // render table
    var table = document.getElementById("table");
    for(var serie in revenues) {
      var row        = document.createElement("TR"),
          label_cell = document.createElement("TD"),
          label_text = document.createTextNode(labels[serie]),
          value_cell = document.createElement("TD"),
          last       = revenues[serie].length - 1,
          value_text = document.createTextNode(revenues[serie][last]);
      label_cell.appendChild(label_text);
      value_cell.appendChild(value_text);
      row.appendChild(label_cell);
      row.appendChild(value_cell);
      table.appendChild(row);
    }
  }
  
  function render_avg_ticket_price() {
    var last = avg_ticket_price.length - 1;
    document.getElementById("avg-ticket-price")
            .appendChild(
              document.createTextNode(avg_ticket_price[last])
            );
  }
  
  function compute_and_render_ticket_revenue() {
    var total;
    for(var i=0; i<revenues["serie-1"].length; i++) {
      total = 0;
      for(var serie in labels) {
        if(labels[serie] == "merchandise") { continue; }
        total += revenues[serie][i];
      }
      ticket_revenues.push(total);
    }
    var total_text = document.createTextNode(total);
    document.getElementById("total-ticket-revenue").appendChild(total_text);
  }

  function compute_and_render_rough_estimate() {
    var last          = ticket_revenues.length - 1,
        estimate      = ticket_revenues[last] / avg_ticket_price[last],
        estimate_text = document.createTextNode(Math.ceil(estimate));
    document.getElementById("rough-estimate").appendChild(estimate_text);
  }
  
  var pricing = {
    "low-budget": [ 180, 200 ],
    "standard":   [ 220 ],
    "supporter":  [ 240, 260, 280, 300 ],
    "business":   [ 450, 600, 750 ]
  };

  function compute_and_render_category_intervals() {
    var minimum = 0, maximum = 0;

    compute_category_intervals();
    compute_ticket_boundaries();

    render_category_intervals();
  }
  
  function compute_category_intervals() {
    for(var serie in labels) {
      if(labels[serie] == "merchandise") { continue; }

      var min   = Math.min.apply(null, pricing[labels[serie]]),
          max   = Math.max.apply(null, pricing[labels[serie]]),
          lower = [],
          upper = [];
      for(var i=0; i<revenues[serie].length; i++) {
        lower.push(Math.floor(revenues[serie][i] / max));
        upper.push(Math.floor(revenues[serie][i] / min));
      }
      tickets[serie] = { "lower": lower, "upper": upper };
    }
  }
  
  function compute_ticket_boundaries() {
    for(var i=0;i<tickets["serie-1"]["lower"].length; i++) {
      var minimum = 0, maximum = 0;
      for(var serie in tickets) {
        minimum += tickets[serie]["lower"][i];
        maximum += tickets[serie]["upper"][i];
      }
      tickets_bounds["minimum"].push(minimum);
      tickets_bounds["maximum"].push(maximum);
    }
  }
  
  function render_category_intervals() {
    for(var serie in tickets) {
      var last = tickets[serie]["lower"].length - 1;
      if(labels[serie] == "standard") {
        document.getElementById(labels[serie] + "-amount").appendChild(
          document.createTextNode(tickets[serie]["lower"][last])
        );
      } else {
        document.getElementById(labels[serie] + "-lower").appendChild(
          document.createTextNode(tickets[serie]["lower"][last])
        );
        document.getElementById(labels[serie] + "-upper").appendChild(
          document.createTextNode(tickets[serie]["upper"][last])
        );
      }
    }

    // totals = minimum and maximum
    for(var loc in { "table":0, "text": 0}) {
      document.getElementById("interval-minimum-"+loc).appendChild(
        document.createTextNode(tickets_bounds["minimum"][last])
      );    
      document.getElementById("interval-maximum-"+loc).appendChild(
        document.createTextNode(tickets_bounds["maximum"][last])
      );    
    }
  }

  Ajax.with_online_prefix("https://tickets.events.ccc.de/media/")
      .using(chart_single_processor).fetch("chart_single.svg");
})();
</script>

</html>
