<!DOCTYPE html>
<meta charset="utf-8">
  <style>

  body, TD, TH, P {
    font: 10px sans-serif;
  }
  
  TD, TH, P {
    font-size: 11pt;
  }
  
  TH {
    font-weight: bold;
  }
  
  table {
    border-collapse: collapse;
  }

  table, th, td {
      border: 1px solid black;
  }
  
  .axis path,
  .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  .bar {
    fill: steelblue;
  }

  .x.axis path {
    display: none;
  }

  </style>
<body>
  <h1>CCCC - Chaos Communication Camp Counter</h1>
  
  <p><b>Done before we even started ;-)</b> - It seems the svg data is not
  allowed to be retrieved outside the original domain, so no live updates are
  possible, and I'm not going to fetch and update the repository with a fresh
  cache every hour/day/... Too bad ;-/</p>
  
  <p><b>BUT...</b> If you're using Safari (FireFox also blocks it, haven't
  tested Chrome, but that comes with a command-line switch to disable it it
  seems, YMMV), you can clone the repo and look at the page locally, because
  from a local file the same-origin check isn't validated it
  appears.<br>Minimal survival commands:
<pre>
  $ git clone https://github.com/christophevg/cccc.git
  $ cd cccc
  $ git checkout gh-pages
  $ open index.html
</pre>
</p>

  <p><b>And then things go pitch black :-)</b> - About 32 hours after the
  opening of the ticket shop, the target graphs were apparently reformatted to
  no longer include overlays with numeric values. Coincidence? I don't care :-)
  But this makes it nearly impossible to extract interesting information from
  it, so ...</p>

  <p>I still had a local copy of one of the early hours, which I've added to
  the repository.</p>
  
  <p><b>IMPORTANT NOTE:</b> I made a stupid mistake, not seeing that the
  revenue data was already stacked initially, meaning that all ticket revenue
  values I was using were including the previous revenues, and therefore way
  too high. I can't reproduce the nice graph of ~30 hours past the opening of
  the ticket shop, but I've fixed the parsing of the snapshot data below.</p>

  <p><b>So, the remaining analysis below this line, only deals with a snapshot,
  taken about 6 hours after the opening of the ticket shop.</b></p>
  
  <hr>

  <p>This is just a little bit of fun, trying to compute the number of hackers
  that will roam <a href="https://events.ccc.de/camp/2015">CCC15</a>. Based on
  the information found in the <a
  href="https://tickets.events.ccc.de/graph/">target graphs</a>, I want to try
  to estimate the number of tickets sold, just to enjoy the vast growing amount
  of hackers I will share the camp grounds with.</p>
  
  <p>On the other hand, its also a case pro Open Data. It's an example of the
  not so cool way of doing things these days. In stead of publishing a json
  file with the data (# of tickets per category, # of t-shirts per category)
  and computing a rendering on the client-side, the data is mangled into one
  representation on the server-side, requiring other consumers to reengineer
  the representation to an approximation of the original data.</p>
  
  <p>I thought hackers would be on the forefront of the openness of where the
  web is heading. Seems I'm wrong :-( (addedum: <b>very wrong</b> it even
  seems)</p>
  
  <p>Finally, it's also an excuse to have a little fun with JavaScript again,
  after a long time, exercising a bit for things to come :-)</p>

  <h2>Data</h2>

  <p>The following tables contain the latest data, extracted from the published
  SVG graphs.</p>
  
  <h3>Revenue</h3>
  <table>
    <thead><tr><th>subject</th><th>&euro;</th></tr></thead>
    <tbody id="table"></tbody>
  </table>
  
  <h3>Average Ticket Price...</h3>

  <p>... is currently computed to &euro;<span id="avg-ticket-price"></span></p>
  
  <h2>Estimation Time</h2>
  
  <p>Let's go from very basic to more specific...</p>
  
  <h3>The very rough one</h3>

  <p>Summing the different ticket revenues, dividing it by the average price,
  gives us a rough estimate of the number of tickets sold. The total in ticket
  revenue is &euro;<span id="total-ticket-revenue"></span>. This brings the
  rough estimate to <b><span id="rough-estimate"></span> campers</b>. </p>
  
  <h3>Taking into Account the Categories</h3>
  
  <p>But different ticket prices are in effect. The goal is to allow those who
  can to <i>chip</i> a bit for those who can't. I think that's commendable. But
  it also means that some payments count for less tickets. Let's start with
  taking into account the categories and come up with an interval.</p>
  
  <p>The following table (as also shown in <a
  href="https://events.ccc.de/camp/2015/wiki/Static:Tickets">https://events.ccc.
   de/camp/2015/wiki/Static:Tickets</a>) gives an overview of the tickets
  categories and their pricing:</p>
  
  <table>
    <thead>
      <tr>
        <th>category</th><th>price</th>
        <th>lower</th><th>upper</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th>Low budget</th><td>&euro;180, &euro;200</td>
        <td id="low-budget-lower"></td><td id="low-budget-upper"></td>
      </tr>
      <tr>
        <th>Standard</th><td>&euro;220</td>
        <td colspan="2" id="standard-amount"></td>
      </tr>
      <tr>
        <th>Supporter</th><td>&euro;240, &euro;260, &euro;280, &euro;300</td>
        <td id="supporter-lower"></td><td id="supporter-upper"></td>
      </tr>
      <tr>
        <th>Business</th><td>&euro;450, &euro;60, &euro;750</td>
        <td id="business-lower"></td><td id="business-upper"></td>
      </tr>
      <tr>
        <th>&nbsp;</th><td>&nbsp;</td>
        <td id="interval-minimum-table"></td><td id="interval-maximum-table"></td>
      </tr>
    </tbody>
  </table>
  
  <p>The two additional columns, provide the lower and upper bound of the
  interval of possible ticket sales given the prices. These numbers allow us to
  add the lower and upper bounds to come up with a minimum and maximum number
  of campers.</p>
  
  <p>Taking the categories into account, the amount of campers to expect can
  range <b>between <span id="interval-minimum-text"></span> and <span
  id="interval-maximum-text"></span></b>.</p>
  
  <h2>Graphs!!!</h2>
  
  <p>Doing all this for the final number of campers is fun, but seeing tickets
  sales evolve over time surely beats it ;-) I've taken the average of the
  upper and lower boundaries of the estimated interval. The X-axis represents
  the hours past the opening of the ticket shop.</p>

  <div id="graph"></div>

</body>

<script src="js/ajax.js"></script>
<script src="js/svg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

<script>
(function() {
  
  var labels           = {};  // { serie-x : label }
  var revenues         = {};  // { serie-x : [value] } // cummulative values
  var ticket_revenues  = [];  // [value]

  var avg_ticket_price = [];  // [value]

  var tickets          = {};  // { serie-x : { upper: [value], lower: [value] }}
  var tickets_bounds   = { "minimum": [], "maximum": [] };

  function chart_single_processor(svg) {
    var doc = Svg.parse(svg);

    // process this graph's data
    extract_series_labels(doc);
    extract_series_revenues(doc);

    // continue with the average ticket price
    Ajax.using(chart_avg_processor).fetch("chart_avg.svg");
  }
  
  function extract_series_labels(doc) {
    // fill labels[serie-x] = label
    var legends = doc.getElementsByClassName("legend reactive activate-serie");
    for(var i=0; i<legends.length; i++) {
      var serie = legends[i].id.replace("activate-", "");
      var label = legends[i].getElementsByTagName("title");
      if(label.length <= 0) { label = legends[i].getElementsByTagName("text"); }
      labels[serie] = label[0].textContent
                              .toLowerCase()
                              .replace(" ", "-");
    }
  }
  
  function extract_series_revenues(doc) {
    // fill revenues[] = { serie: [revenues] }
    var series = doc.getElementsByClassName("plot overlay")[0]
                    .getElementsByClassName("series");
    for(var i=0; i<series.length; i++) {
      extract_revenues(series[i])
    }
    // these revenues are stacked already, so we need to remove them again :-(
    for(var serie1 in revenues) {  // remove this from every following
      var active = false;
      for(var serie2 in revenues) {
        if(!active) {
          active = serie1 == serie2;
          continue;
        }
        for(var i=0; i<revenues[serie1].length; i++) {
          revenues[serie2][i] -= revenues[serie1][i];
        }
      }
    }
  }
  
  function extract_revenues(series) {
    // -> let's believe the series are named serie-x ;-)
    var id = series.className.baseVal.match(/serie-[0-9]/)[0];
    // dots is the actual series
    var dots  = series.getElementsByClassName("dots");

    revenues[id] = [];
    for(var i=0; i<dots.length;i++) {
      revenues[id].push( parseInt(
        dots[i].getElementsByClassName("value")[0].textContent
      ));
    }
  }
  
  function chart_avg_processor(svg) {
    var doc = Svg.parse(svg);

    var series = doc.getElementsByClassName("plot overlay")[0]
                    .getElementsByClassName("series")[0]
                    .getElementsByClassName("dots");
    for(var i=0; i<series.length;i++) {
      avg_ticket_price.push( parseFloat(
        series[i].getElementsByClassName("value")[0].textContent
      ));
    }
  
    // now compute and render results
    process_data();
  }
  
  function process_data() {
    render_totals_table();
    render_avg_ticket_price();
    compute_and_render_ticket_revenue();
    compute_and_render_rough_estimate();
    compute_and_render_category_intervals();
  }

  function render_totals_table() {
    // render table
    var table = document.getElementById("table");
    for(var serie in revenues) {
      var row        = document.createElement("TR"),
          label_cell = document.createElement("TD"),
          label_text = document.createTextNode(labels[serie]),
          value_cell = document.createElement("TD"),
          last       = revenues[serie].length - 1,
          value_text = document.createTextNode(revenues[serie][last]);
      label_cell.appendChild(label_text);
      value_cell.appendChild(value_text);
      row.appendChild(label_cell);
      row.appendChild(value_cell);
      table.appendChild(row);
    }
  }
  
  function render_avg_ticket_price() {
    var last = avg_ticket_price.length - 1;
    document.getElementById("avg-ticket-price")
            .appendChild(
              document.createTextNode(avg_ticket_price[last])
            );
  }
  
  function compute_and_render_ticket_revenue() {
    var total;
    for(var i=0; i<revenues["serie-1"].length; i++) {
      total = 0;
      for(var serie in labels) {
        if(labels[serie] == "merchandise") { continue; }
        total += revenues[serie][i];
      }
      ticket_revenues.push(total);
    }
    var total_text = document.createTextNode(total);
    document.getElementById("total-ticket-revenue").appendChild(total_text);
  }

  function compute_and_render_rough_estimate() {
    var last          = ticket_revenues.length - 1,
        estimate      = ticket_revenues[last] / avg_ticket_price[last],
        estimate_text = document.createTextNode(Math.ceil(estimate));
    document.getElementById("rough-estimate").appendChild(estimate_text);
  }
  
  var pricing = {
    "low-budget": [ 180, 200 ],
    "standard":   [ 220 ],
    "supporter":  [ 240, 260, 280, 300 ],
    "business":   [ 450, 600, 750 ]
  };

  function compute_and_render_category_intervals() {
    var minimum = 0, maximum = 0;

    compute_category_intervals();
    compute_ticket_boundaries();

    render_category_intervals();
    
    render_graph();
  }
  
  function compute_category_intervals() {
    for(var serie in labels) {
      if(labels[serie] == "merchandise") { continue; }

      var min   = Math.min.apply(null, pricing[labels[serie]]),
          max   = Math.max.apply(null, pricing[labels[serie]]),
          lower = [],
          upper = [];
      for(var i=0; i<revenues[serie].length; i++) {
        lower.push(Math.floor(revenues[serie][i] / max));
        upper.push(Math.floor(revenues[serie][i] / min));
      }
      tickets[serie] = { "lower": lower, "upper": upper };
    }
  }
  
  function compute_ticket_boundaries() {
    for(var i=0;i<tickets["serie-1"]["lower"].length; i++) {
      var minimum = 0, maximum = 0;
      for(var serie in tickets) {
        minimum += tickets[serie]["lower"][i];
        maximum += tickets[serie]["upper"][i];
      }
      tickets_bounds["minimum"].push(minimum);
      tickets_bounds["maximum"].push(maximum);
    }
  }
  
  function render_category_intervals() {
    for(var serie in tickets) {
      var last = tickets[serie]["lower"].length - 1;
      if(labels[serie] == "standard") {
        document.getElementById(labels[serie] + "-amount").appendChild(
          document.createTextNode(tickets[serie]["lower"][last])
        );
      } else {
        document.getElementById(labels[serie] + "-lower").appendChild(
          document.createTextNode(tickets[serie]["lower"][last])
        );
        document.getElementById(labels[serie] + "-upper").appendChild(
          document.createTextNode(tickets[serie]["upper"][last])
        );
      }
    }

    // totals = minimum and maximum
    for(var loc in { "table":0, "text": 0}) {
      document.getElementById("interval-minimum-"+loc).appendChild(
        document.createTextNode(tickets_bounds["minimum"][last])
      );    
      document.getElementById("interval-maximum-"+loc).appendChild(
        document.createTextNode(tickets_bounds["maximum"][last])
      );    
    }
  }
  
  function render_graph() {
    var margin = {top: 20, right: 20, bottom: 30, left: 40},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var x = d3.scale.ordinal()
        .rangeRoundBands([0, width], .1);

    var y = d3.scale.linear()
        .rangeRound([height, 0]);

    var color = d3.scale.ordinal()
        .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b" ]);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickFormat(d3.format(".2s"));

    var svg = d3.select("#graph").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // CSV
    // series, Low Budget, Standard, Supporter, Business
    // 0, ...
    // 1, ...

    // DATA
    // [ { hour: "+0", "serie": x, ... } ]
    
    var data = [];
    for(var i=0; i<tickets["serie-1"]["lower"].length; i++) {
      var d = { "hour" : "+" + i };
      for(var serie in tickets ) {
        d[labels[serie]] = Math.ceil( (  tickets[serie]["lower"][i]
                                       + tickets[serie]["upper"][i]) / 2);
      }
      data.push(d);
    }
    
    color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "hour";
    }));

    data.forEach(function(d) {
      var y0 = 0;
      d.amount = color.domain().map(function(name) {
        return {name: name, y0: y0, y1: y0 += +d[name]};
      });
      d.total  = d.amount[d.amount.length - 1].y1;
    });

    x.domain(data.map(function(d) { return d.hour; }));
    y.domain([0, d3.max(data, function(d) { return d.total; })]);

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Population");

    var state = svg.selectAll(".state")
        .data(data)
      .enter().append("g")
        .attr("class", "g")
        .attr("transform", function(d) {
          return "translate(" + x(d.hour) + ",0)";
        });

    state.selectAll("rect")
        .data(function(d) { return d.amount; })
      .enter().append("rect")
        .attr("width", x.rangeBand())
        .attr("y", function(d) { return y(d.y1); })
        .attr("height", function(d) { return y(d.y0) - y(d.y1); })
        .style("fill", function(d) { return color(d.name); });

    var legend = svg.selectAll(".legend")
        .data(color.domain().slice().reverse())
      .enter().append("g")
        .attr("class", "legend")
        .attr("transform", function(d, i) {
          return "translate(-800," + i * 20 + ")";
        });

    legend.append("rect")
        .attr("x", width - 18)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", color);

    legend.append("text")
        .attr("x", width - 24)
        .attr("y", 9)
        .attr("dy", ".35em")
        .style("text-anchor", "end")
        .text(function(d) { return d; });
  }

  Ajax.with_online_prefix("https://tickets.events.ccc.de/media/")
      .using(chart_single_processor).fetch("chart_single.svg");
})();
</script>

</html>
